#!/bin/python3

import math
import os
import random
import re
import sys
from collections import deque


LOCAL_INPUT = "ON"


class CitiesAndRoads:
    def __init__(self):
        self.citiesToRoads = {}

    def addCity(self, city):
        self.citiesToRoads[city] = set()

    def addRoad(self, startCity, endCity):
        self.citiesToRoads[startCity].add(endCity)

    def visitConnectableCities(self, startCity):
        citiesToVisit = deque()

        citiesToVisit.appendleft(startCity)
        visitedCities = set()

        while citiesToVisit:
            currentCity = citiesToVisit.pop()
            visitedCities.add(currentCity)

            neighborCities = self.citiesToRoads[currentCity]
            for neighborCity in neighborCities:
                if neighborCity not in visitedCities:
                    citiesToVisit.appendleft(neighborCity)
                    visitedCities.add(neighborCity)

        return visitedCities

    def countGroupsOfConnectableCities(self, startCity):
        initialCitiesSet = set(self.citiesToRoads.keys())

        connectableCitiesFromStart = self.visitConnectableCities(startCity)
        cityGroupsCounter = 1

        if connectableCitiesFromStart == initialCitiesSet:
            pass
        else:
            visitedCitiesSet = set()

            while initialCitiesSet != visitedCitiesSet:
                citiesToVisit = [city for city in initialCitiesSet if city not in visitedCitiesSet]
                unconnectedCitiesFromStart = []
                for city in citiesToVisit:
                    if city not in connectableCitiesFromStart:
                        unconnectedCitiesFromStart.append(city)
                    else:
                        visitedCitiesSet.add(city)

                if len(unconnectedCitiesFromStart) != 0:
                    connectableCitiesFromStart = self.visitConnectableCities(unconnectedCitiesFromStart[0])
                    cityGroupsCounter += 1

        return cityGroupsCounter


    def getMinimumCost(self, citiesNum, libraryCost, roadCost, startCity):
        communitiesNum = self.countGroupsOfConnectableCities(startCity)
        minimalRoadsCost = (citiesNum - communitiesNum) * roadCost
        libraryEachCommunityCost = communitiesNum * libraryCost
        allLibrariesCost = libraryCost * citiesNum

        if allLibrariesCost >= minimalRoadsCost + libraryEachCommunityCost:
            return minimalRoadsCost + libraryEachCommunityCost

        return allLibrariesCost


def createPossibleRoadsMap():
    roadsBetweenCities = []
    for _ in range(roadsNum):
        roadsBetweenCities.append(list(map(int, input().rstrip().split())))

    citiesWithRoads = CitiesAndRoads()
    for city in range(1, citiesNum + 1):
        citiesWithRoads.addCity(city)

    for road in roadsBetweenCities:
        citiesWithRoads.addRoad(road[0], road[1])
        citiesWithRoads.addRoad(road[1], road[0])
    return citiesWithRoads

if __name__ == '__main__':

    if LOCAL_INPUT == "ON":
        sys.stdin = open('RoadsAndLibraries_input.txt')

        q = int(input())

        for q_itr in range(q):
            nmC_libC_road = input().split()
            citiesNum = int(nmC_libC_road[0])
            roadsNum = int(nmC_libC_road[1])
            libraryCost = int(nmC_libC_road[2])
            roadCost = int(nmC_libC_road[3])
            citiesWithRoads = createPossibleRoadsMap()
            startCity = 1
            minimalCost = citiesWithRoads.getMinimumCost(citiesNum, libraryCost, roadCost, startCity)
            print(minimalCost)

    elif LOCAL_INPUT == "OFF":
        with open(os.environ['OUTPUT_PATH'], 'w') as fptr:
            q = int(input())

            for q_itr in range(q):
                nmC_libC_road = input().split()
                citiesNum = int(nmC_libC_road[0])
                roadsNum = int(nmC_libC_road[1])
                libraryCost = int(nmC_libC_road[2])
                roadCost = int(nmC_libC_road[3])
                citiesWithRoads = createPossibleRoadsMap()
                startCity = 1
                minimalCost = citiesWithRoads.getMinimumCost(citiesNum, libraryCost, roadCost, startCity)
                fptr.write(str(minimalCost) + '\n')

    else:
        print("Please set LOCAL_INPUT to 'ON' or 'OFF'.")


# 5
# 9 2 91 84
# 8 2
# 2 9
# 5 9 92 23
# 2 1
# 5 3
# 5 1
# 3 4
# 3 1
# 5 4
# 4 1
# 5 2
# 4 2
# 8 3 10 55
# 6 4
# 3 2
# 7 1
# 1 0 5 3
# 2 0 102 1



