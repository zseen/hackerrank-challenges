#!/bin/python3

import math
import os
import random
import re
import sys
from collections import deque


LOCAL_INPUT = "ON"


class CitiesAndRoads:
    def __init__(self):
        self.citiesToRoads = {}

    def addCity(self, city):
        self.citiesToRoads[city] = set()

    def addRoad(self, startCity, endCity):
        self.citiesToRoads[startCity].add(endCity)

    def visitConnectableCities(self, startCity):
        citiesToVisit = deque()

        citiesToVisit.appendleft(startCity)
        visitedCities = set()

        while citiesToVisit:
            currentCity = citiesToVisit.pop()
            visitedCities.add(currentCity)

            neighborCities = self.citiesToRoads[currentCity]
            for neighborCity in neighborCities:
                if neighborCity not in visitedCities:
                    citiesToVisit.appendleft(neighborCity)
                    visitedCities.add(neighborCity)

        return visitedCities

    def countGroupsOfConnectableCities(self, startCity):
        initialCitiesSet = set(self.citiesToRoads.keys())

        connectableCitiesFromStart = self.visitConnectableCities(startCity)

        visitedCitiesSet = set()

        cityGroupsCounter = 1

        while initialCitiesSet != visitedCitiesSet:
            citiesToVisit = [city for city in initialCitiesSet if city not in visitedCitiesSet]
            unconnectedCitiesFromStart = []
            for city in citiesToVisit:
                if city not in connectableCitiesFromStart:
                    unconnectedCitiesFromStart.append(city)
                else:
                    visitedCitiesSet.add(city)

            if len(unconnectedCitiesFromStart) != 0:
                connectableCitiesFromStart = self.visitConnectableCities(unconnectedCitiesFromStart[0])
                cityGroupsCounter += 1

        return cityGroupsCounter


    def getMinimumCost(self, citiesNum, libraryCost, roadCost, startCity):
        communitiesNum = self.countGroupsOfConnectableCities(startCity)
        minimalRoadsCost = (citiesNum - communitiesNum) * roadCost
        libraryEachCommunityCost = communitiesNum * libraryCost
        allLibrariesCost = libraryCost * citiesNum

        if allLibrariesCost >= minimalRoadsCost + libraryEachCommunityCost:
            return minimalRoadsCost + libraryEachCommunityCost

        return allLibrariesCost


if __name__ == '__main__':

    if LOCAL_INPUT == "ON":
        sys.stdin = open('RoadsAndLibraries_input.txt')

        q = int(input())

        for q_itr in range(q):
            nmC_libC_road = input().split()
            citiesNum = int(nmC_libC_road[0])
            roadsNum = int(nmC_libC_road[1])
            libraryCost = int(nmC_libC_road[2])
            roadCost = int(nmC_libC_road[3])
            roadsBetweenCities = []
            for _ in range(roadsNum):
                roadsBetweenCities.append(list(map(int, input().rstrip().split())))
            citiesWithRoads = CitiesAndRoads()

            for city in range(1, citiesNum + 1):
                citiesWithRoads.addCity(city)

            startCity = 1

            for road in roadsBetweenCities:
                citiesWithRoads.addRoad(road[0], road[1])
                citiesWithRoads.addRoad(road[1], road[0])

            minimalCost = citiesWithRoads.getMinimumCost(citiesNum, libraryCost, roadCost, startCity)
            print(minimalCost)

    elif LOCAL_INPUT == "OFF":
        with open(os.environ['OUTPUT_PATH'], 'w') as fptr:
            q = int(input())

            for q_itr in range(q):
                nmC_libC_road = input().split()
                citiesNum = int(nmC_libC_road[0])
                roadsNum = int(nmC_libC_road[1])
                libraryCost = int(nmC_libC_road[2])
                roadCost = int(nmC_libC_road[3])
                roadsBetweenCities = []
                for _ in range(roadsNum):
                    roadsBetweenCities.append(list(map(int, input().rstrip().split())))
                citiesWithRoads = CitiesAndRoads()

                for city in range(1, citiesNum + 1):
                    citiesWithRoads.addCity(city)

                startCity = 1

                for road in roadsBetweenCities:
                    citiesWithRoads.addRoad(road[0], road[1])
                    citiesWithRoads.addRoad(road[1], road[0])

                minimalCost = citiesWithRoads.getMinimumCost(citiesNum, libraryCost, roadCost, startCity)

                fptr.write(str(minimalCost) + '\n')

    else:
        print("Please set LOCAL_INPUT to 'ON' or 'OFF'.")



