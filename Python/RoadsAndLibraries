#!/bin/python3

import math
import os
import random
import re
import sys
from collections import deque


LOCAL_INPUT = "ON"


class CitiesAndRoads:
    def __init__(self):
        self.nodesToEdges = {}

    def addNode(self, nodeId):
        self.nodesToEdges[nodeId] = set()

    def addEdge(self, startNodeId, endNodeId):
        self.nodesToEdges[startNodeId].add(endNodeId)

    def visitConnectableNodes(self, startNodeId):
        nodesToVisit = deque()

        nodesToVisit.appendleft(startNodeId)
        visitedNodes = set()

        while nodesToVisit:
            currentNode = nodesToVisit.pop()
            visitedNodes.add(currentNode)

            neighborNodes = self.nodesToEdges[currentNode]
            for neighborNode in neighborNodes:
                if neighborNode not in visitedNodes:
                    nodesToVisit.appendleft(neighborNode)
                    visitedNodes.add(neighborNode)

        return visitedNodes

    def countGroupsOfConnectableNodes(self, startNodeId):
        initialNodesSet = set(self.nodesToEdges.keys())
        connectableNodesFromStart = self.visitConnectableNodes(startNodeId)
        nodeGroupsCounter = 1

        if connectableNodesFromStart == initialNodesSet:
            pass
        else:
            visitedNodesSet = set()
            while initialNodesSet != visitedNodesSet:
                nodesToVisit = [nodeId for nodeId in initialNodesSet if nodeId not in visitedNodesSet]
                unconnectedNodesFromStart = []
                for nodeId in nodesToVisit:
                    if nodeId not in connectableNodesFromStart:
                        unconnectedNodesFromStart.append(nodeId)
                    else:
                        visitedNodesSet.add(nodeId)

                if len(unconnectedNodesFromStart) != 0:
                    connectableNodesFromStart = self.visitConnectableNodes(unconnectedNodesFromStart[0])
                    nodeGroupsCounter += 1

        return nodeGroupsCounter

    def getMinimumCost(self, citiesNum, libraryCost, roadCost, startCity):
        communitiesNum = self.countGroupsOfConnectableNodes(startCity)
        minimalRoadsCost = (citiesNum - communitiesNum) * roadCost
        libraryEachCommunityCost = communitiesNum * libraryCost
        allLibrariesCost = libraryCost * citiesNum

        if allLibrariesCost >= minimalRoadsCost + libraryEachCommunityCost:
            return minimalRoadsCost + libraryEachCommunityCost

        return allLibrariesCost


def createPossibleRoadsMap(roadsNum, citiesNum):
    roadsBetweenCities = []
    for _ in range(roadsNum):
        roadsBetweenCities.append(list(map(int, input().rstrip().split())))

    citiesWithRoads = CitiesAndRoads()
    for city in range(1, citiesNum + 1):
        citiesWithRoads.addNode(city)

    for road in roadsBetweenCities:
        citiesWithRoads.addEdge(road[0], road[1])
        citiesWithRoads.addEdge(road[1], road[0])
    return citiesWithRoads


def main():
    if LOCAL_INPUT == "ON":
        sys.stdin = open('RoadsAndLibraries_input.txt')
        q = int(input())
        for q_itr in range(q):
            nmC_libC_road = input().split()
            citiesNum = int(nmC_libC_road[0])
            roadsNum = int(nmC_libC_road[1])
            libraryCost = int(nmC_libC_road[2])
            roadCost = int(nmC_libC_road[3])
            citiesWithRoads = createPossibleRoadsMap(roadsNum, citiesNum)
            startCity = 1
            minimalCost = citiesWithRoads.getMinimumCost(citiesNum, libraryCost, roadCost, startCity)
            print(minimalCost)

    elif LOCAL_INPUT == "OFF":
        with open(os.environ['OUTPUT_PATH'], 'w') as fptr:
            q = int(input())
            for q_itr in range(q):
                nmC_libC_road = input().split()
                citiesNum = int(nmC_libC_road[0])
                roadsNum = int(nmC_libC_road[1])
                libraryCost = int(nmC_libC_road[2])
                roadCost = int(nmC_libC_road[3])
                citiesWithRoads = createPossibleRoadsMap(roadsNum, citiesNum)
                startCity = 1
                minimalCost = citiesWithRoads.getMinimumCost(citiesNum, libraryCost, roadCost, startCity)
                fptr.write(str(minimalCost) + '\n')

    else:
        print("Please set LOCAL_INPUT to 'ON' or 'OFF'.")


if __name__ == '__main__':
    main()





